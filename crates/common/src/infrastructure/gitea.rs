//! Gitea Installation Module
//!
//! This module handles deploying Gitea via Helm chart with OCI registry support.
//! It configures persistent storage, admin credentials, and webhooks for CI integration.

use anyhow::{anyhow, Context, Result};
use std::fs;
use std::path::PathBuf;
use std::process::Command;
use tracing::{debug, info, warn};

/// Gitea Helm chart configuration
const GITEA_CHART_REPO: &str = "https://dl.gitea.io/charts/";
const GITEA_CHART_NAME: &str = "gitea-charts/gitea";
const GITEA_CHART_VERSION: &str = "10.1.4";
const GITEA_NAMESPACE: &str = "gitea";
const GITEA_RELEASE_NAME: &str = "gitea";

/// Gitea installation configuration
#[derive(Debug, Clone)]
pub struct GiteaConfig {
    /// Gitea version to install
    pub version: String,
    /// Namespace for Gitea deployment
    pub namespace: String,
    /// Helm release name
    pub release_name: String,
    /// Admin username
    pub admin_user: String,
    /// Admin password
    pub admin_password: String,
    /// Admin email
    pub admin_email: String,
    /// Storage size for repositories (in Gi)
    pub storage_size: String,
    /// Storage class name
    pub storage_class: String,
    /// Enable OCI registry
    pub enable_oci_registry: bool,
    /// Service type (NodePort or LoadBalancer)
    pub service_type: ServiceType,
    /// HTTP port (for NodePort)
    pub http_node_port: Option<u16>,
    /// SSH port (for NodePort)
    pub ssh_node_port: Option<u16>,
    /// Kubeconfig path
    pub kubeconfig_path: PathBuf,
}

/// Service type for Gitea exposure
#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ServiceType {
    NodePort,
    #[allow(dead_code)]
    LoadBalancer,
    #[allow(dead_code)]
    ClusterIP,
}

impl ServiceType {
    #[allow(dead_code)]
    pub fn as_str(&self) -> &str {
        match self {
            ServiceType::NodePort => "NodePort",
            ServiceType::LoadBalancer => "LoadBalancer",
            ServiceType::ClusterIP => "ClusterIP",
        }
    }
}

impl Default for GiteaConfig {
    fn default() -> Self {
        let home = dirs::home_dir().unwrap_or_else(|| PathBuf::from("/root"));
        Self {
            version: GITEA_CHART_VERSION.to_string(),
            namespace: GITEA_NAMESPACE.to_string(),
            release_name: GITEA_RELEASE_NAME.to_string(),
            admin_user: "raibid-admin".to_string(),
            admin_password: Self::generate_password(),
            admin_email: "admin@raibid.local".to_string(),
            storage_size: "10Gi".to_string(),
            storage_class: "local-path".to_string(), // k3s default
            enable_oci_registry: true,
            service_type: ServiceType::NodePort,
            http_node_port: Some(30080),
            ssh_node_port: Some(30022),
            kubeconfig_path: home.join(".kube").join("config"),
        }
    }
}

impl GiteaConfig {
    /// Generate a random password for admin account
    fn generate_password() -> String {
        use rand::Rng;
        const CHARSET: &[u8] =
            b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
        let mut rng = rand::thread_rng();

        (0..16)
            .map(|_| {
                let idx = rng.gen_range(0..CHARSET.len());
                CHARSET[idx] as char
            })
            .collect()
    }

    /// Generate Helm values YAML for Gitea installation
    pub fn generate_helm_values(&self) -> String {
        let service_config = match self.service_type {
            ServiceType::NodePort => {
                format!(
                    r#"  type: NodePort
  http:
    type: NodePort
    port: 3000
    nodePort: {}
  ssh:
    type: NodePort
    port: 22
    nodePort: {}"#,
                    self.http_node_port.unwrap_or(30080),
                    self.ssh_node_port.unwrap_or(30022)
                )
            }
            ServiceType::LoadBalancer => r#"  type: LoadBalancer
  http:
    type: LoadBalancer
    port: 3000
  ssh:
    type: LoadBalancer
    port: 22"#
                .to_string(),
            ServiceType::ClusterIP => r#"  type: ClusterIP
  http:
    type: ClusterIP
    port: 3000
  ssh:
    type: ClusterIP
    port: 22"#
                .to_string(),
        };

        let oci_config = if self.enable_oci_registry {
            r#"
  - name: packages.enabled
    value: "true"
  - name: packages.ENABLED
    value: "true""#
        } else {
            ""
        };

        format!(
            r#"# Gitea Helm Values
# Generated by raibid-cli

# Redis for cache and queue
redis-cluster:
  enabled: false

redis:
  enabled: true
  architecture: standalone

# PostgreSQL database
postgresql:
  enabled: true
  auth:
    database: gitea
    username: gitea
    password: gitea-db-password
  primary:
    persistence:
      enabled: true
      size: 5Gi

# Gitea configuration
gitea:
  admin:
    username: {}
    password: {}
    email: {}

  config:
    APP_NAME: "Raibid CI - Git Server"
    RUN_MODE: prod

    server:
      PROTOCOL: http
      DOMAIN: localhost
      ROOT_URL: http://localhost:3000/
      DISABLE_SSH: false
      SSH_DOMAIN: localhost
      SSH_PORT: 22
      SSH_LISTEN_PORT: 22
      START_SSH_SERVER: true

    database:
      DB_TYPE: postgres
      HOST: gitea-postgresql:5432
      NAME: gitea
      USER: gitea
      PASSWD: gitea-db-password

    repository:
      ROOT: /data/git/repositories
      DEFAULT_BRANCH: main

    webhook:
      ALLOWED_HOST_LIST: "*"
      SKIP_TLS_VERIFY: true

    actions:
      ENABLED: true

    packages:
      ENABLED: {}
{}

# Persistence
persistence:
  enabled: true
  size: {}
  storageClass: {}

# Service configuration
service:
{}

# Ingress disabled (using NodePort/LoadBalancer)
ingress:
  enabled: false
"#,
            self.admin_user,
            self.admin_password,
            self.admin_email,
            if self.enable_oci_registry {
                "true"
            } else {
                "false"
            },
            oci_config,
            self.storage_size,
            self.storage_class,
            service_config
        )
    }
}

/// Gitea installer
pub struct GiteaInstaller {
    config: GiteaConfig,
    values_file: PathBuf,
}

impl GiteaInstaller {
    /// Create a new Gitea installer with default configuration
    pub fn new() -> Result<Self> {
        Self::with_config(GiteaConfig::default())
    }

    /// Create a new Gitea installer with custom configuration
    pub fn with_config(config: GiteaConfig) -> Result<Self> {
        let values_file = std::env::temp_dir()
            .join("raibid-gitea-values")
            .join("values.yaml");

        Ok(Self {
            config,
            values_file,
        })
    }

    /// Check if kubectl is available
    pub fn check_kubectl(&self) -> Result<()> {
        let output = Command::new("kubectl")
            .arg("version")
            .arg("--client")
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .output()
            .context("Failed to run kubectl. Is kubectl installed?")?;

        if !output.status.success() {
            return Err(anyhow!("kubectl is not available or not working properly"));
        }

        Ok(())
    }

    /// Check if Helm is available
    pub fn check_helm(&self) -> Result<()> {
        let output = Command::new("helm")
            .arg("version")
            .output()
            .context("Failed to run helm. Is Helm installed?")?;

        if !output.status.success() {
            return Err(anyhow!("Helm is not available or not working properly"));
        }

        Ok(())
    }

    /// Install Helm if not present
    pub fn install_helm(&self) -> Result<()> {
        info!("Installing Helm");

        // Download Helm install script
        let script_path = std::env::temp_dir().join("get_helm.sh");

        let script_content = reqwest::blocking::get(
            "https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3",
        )
        .context("Failed to download Helm install script")?
        .text()
        .context("Failed to read Helm install script")?;

        fs::write(&script_path, script_content).context("Failed to write Helm install script")?;

        // Make script executable
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&script_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&script_path, perms)?;
        }

        // Run install script
        let output = Command::new("bash")
            .arg(&script_path)
            .output()
            .context("Failed to run Helm install script")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("Helm installation failed: {}", stderr));
        }

        // Cleanup
        let _ = fs::remove_file(&script_path);

        info!("Helm installed successfully");
        Ok(())
    }

    /// Create namespace for Gitea
    pub fn create_namespace(&self) -> Result<()> {
        info!("Creating namespace: {}", self.config.namespace);

        let output = Command::new("kubectl")
            .arg("create")
            .arg("namespace")
            .arg(&self.config.namespace)
            .arg("--dry-run=client")
            .arg("-o")
            .arg("yaml")
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .output()
            .context("Failed to generate namespace YAML")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("Failed to generate namespace YAML: {}", stderr));
        }

        let yaml = String::from_utf8_lossy(&output.stdout);

        let apply_output = Command::new("kubectl")
            .arg("apply")
            .arg("-f")
            .arg("-")
            .stdin(std::process::Stdio::piped())
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .spawn()
            .and_then(|mut child| {
                if let Some(mut stdin) = child.stdin.take() {
                    use std::io::Write;
                    stdin.write_all(yaml.as_bytes())?;
                }
                child.wait_with_output()
            })
            .context("Failed to create namespace")?;

        if !apply_output.status.success() {
            let stderr = String::from_utf8_lossy(&apply_output.stderr);
            return Err(anyhow!("Failed to create namespace: {}", stderr));
        }

        info!("Namespace created: {}", self.config.namespace);
        Ok(())
    }

    /// Add Gitea Helm repository
    pub fn add_helm_repo(&self) -> Result<()> {
        info!("Adding Gitea Helm repository");

        let output = Command::new("helm")
            .arg("repo")
            .arg("add")
            .arg("gitea-charts")
            .arg(GITEA_CHART_REPO)
            .output()
            .context("Failed to add Gitea Helm repository")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            // Ignore error if repo already exists
            if !stderr.contains("already exists") {
                return Err(anyhow!("Failed to add Helm repository: {}", stderr));
            }
        }

        // Update repo
        let update_output = Command::new("helm")
            .arg("repo")
            .arg("update")
            .output()
            .context("Failed to update Helm repositories")?;

        if !update_output.status.success() {
            let stderr = String::from_utf8_lossy(&update_output.stderr);
            return Err(anyhow!("Failed to update Helm repositories: {}", stderr));
        }

        info!("Gitea Helm repository added");
        Ok(())
    }

    /// Write Helm values file
    fn write_values_file(&self) -> Result<()> {
        info!("Generating Helm values file");

        // Create directory
        if let Some(parent) = self.values_file.parent() {
            fs::create_dir_all(parent).context("Failed to create values file directory")?;
        }

        // Generate and write values
        let values = self.config.generate_helm_values();
        fs::write(&self.values_file, values).context("Failed to write Helm values file")?;

        debug!("Helm values written to: {:?}", self.values_file);
        Ok(())
    }

    /// Deploy Gitea via Helm
    pub fn deploy_helm_chart(&self) -> Result<()> {
        info!("Deploying Gitea Helm chart");

        // Write values file
        self.write_values_file()?;

        // Install/upgrade Gitea
        let mut cmd = Command::new("helm");
        cmd.arg("upgrade")
            .arg("--install")
            .arg(&self.config.release_name)
            .arg(GITEA_CHART_NAME)
            .arg("--namespace")
            .arg(&self.config.namespace)
            .arg("--create-namespace")
            .arg("--version")
            .arg(&self.config.version)
            .arg("--values")
            .arg(&self.values_file)
            .arg("--wait")
            .arg("--timeout")
            .arg("10m")
            .env("KUBECONFIG", &self.config.kubeconfig_path);

        debug!("Running Helm command: {:?}", cmd);

        let output = cmd.output().context("Failed to run Helm upgrade")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            let stdout = String::from_utf8_lossy(&output.stdout);
            return Err(anyhow!(
                "Helm deployment failed:\nSTDOUT: {}\nSTDERR: {}",
                stdout,
                stderr
            ));
        }

        info!("Gitea Helm chart deployed successfully");
        Ok(())
    }

    /// Wait for Gitea pods to be ready
    pub fn wait_for_ready(&self) -> Result<()> {
        info!("Waiting for Gitea pods to be ready");

        let output = Command::new("kubectl")
            .arg("wait")
            .arg("--for=condition=ready")
            .arg("pod")
            .arg("-l")
            .arg(format!(
                "app.kubernetes.io/name=gitea,app.kubernetes.io/instance={}",
                self.config.release_name
            ))
            .arg("--namespace")
            .arg(&self.config.namespace)
            .arg("--timeout=600s")
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .output()
            .context("Failed to wait for pods")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("Failed waiting for Gitea pods: {}", stderr));
        }

        info!("Gitea pods are ready");
        Ok(())
    }

    /// Get Gitea service information
    pub fn get_service_info(&self) -> Result<ServiceInfo> {
        info!("Getting Gitea service information");

        let output = Command::new("kubectl")
            .arg("get")
            .arg("service")
            .arg(format!("{}-http", self.config.release_name))
            .arg("--namespace")
            .arg(&self.config.namespace)
            .arg("-o")
            .arg("jsonpath={.spec.type},{.spec.ports[0].nodePort},{.status.loadBalancer.ingress[0].ip}")
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .output()
            .context("Failed to get service info")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("Failed to get service info: {}", stderr));
        }

        let info = String::from_utf8_lossy(&output.stdout);
        let parts: Vec<&str> = info.split(',').collect();

        let service_type = parts.get(0).unwrap_or(&"Unknown").to_string();
        let node_port = parts.get(1).and_then(|s| s.parse::<u16>().ok());
        let load_balancer_ip = parts
            .get(2)
            .filter(|s| !s.is_empty())
            .map(|s| s.to_string());

        Ok(ServiceInfo {
            service_type,
            node_port,
            load_balancer_ip,
            namespace: self.config.namespace.clone(),
        })
    }

    /// Validate Gitea installation
    pub fn validate_installation(&self) -> Result<()> {
        info!("Validating Gitea installation");

        // Check if Helm release exists
        let output = Command::new("helm")
            .arg("list")
            .arg("--namespace")
            .arg(&self.config.namespace)
            .arg("--filter")
            .arg(&self.config.release_name)
            .arg("-o")
            .arg("json")
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .output()
            .context("Failed to list Helm releases")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("Failed to list Helm releases: {}", stderr));
        }

        let releases = String::from_utf8_lossy(&output.stdout);
        if !releases.contains(&self.config.release_name) {
            return Err(anyhow!("Gitea release not found"));
        }

        // Check if pods are running
        let pod_output = Command::new("kubectl")
            .arg("get")
            .arg("pods")
            .arg("--namespace")
            .arg(&self.config.namespace)
            .arg("-l")
            .arg(format!(
                "app.kubernetes.io/instance={}",
                self.config.release_name
            ))
            .arg("-o")
            .arg("jsonpath={.items[*].status.phase}")
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .output()
            .context("Failed to get pod status")?;

        if !pod_output.status.success() {
            let stderr = String::from_utf8_lossy(&pod_output.stderr);
            return Err(anyhow!("Failed to get pod status: {}", stderr));
        }

        let phases = String::from_utf8_lossy(&pod_output.stdout);
        if !phases.contains("Running") {
            warn!("Not all Gitea pods are Running yet: {}", phases);
        } else {
            info!("Gitea validation successful - pods are Running");
        }

        Ok(())
    }

    /// Cleanup temporary files
    pub fn cleanup(&self) -> Result<()> {
        if let Some(parent) = self.values_file.parent() {
            if parent.exists() {
                fs::remove_dir_all(parent).context("Failed to cleanup values directory")?;
                debug!("Cleaned up values directory");
            }
        }
        Ok(())
    }

    /// Complete Gitea installation workflow
    #[allow(dead_code)]
    pub async fn install(&self) -> Result<()> {
        info!("Starting Gitea installation");

        // Check prerequisites
        self.check_kubectl()?;

        // Install Helm if needed
        if self.check_helm().is_err() {
            self.install_helm()?;
        }

        // Create namespace
        self.create_namespace()?;

        // Add Helm repository
        self.add_helm_repo()?;

        // Deploy Helm chart
        self.deploy_helm_chart()?;

        // Wait for pods to be ready
        self.wait_for_ready()?;

        // Validate installation
        self.validate_installation()?;

        // Get service info
        let service_info = self.get_service_info()?;
        info!("Gitea is accessible at: {}", service_info.access_url());

        // Print admin credentials
        info!("Admin username: {}", self.config.admin_user);
        info!("Admin password: {}", self.config.admin_password);

        info!("Gitea installation completed successfully");

        Ok(())
    }

    /// Rollback Gitea installation
    pub fn rollback(&self) -> Result<()> {
        warn!("Rolling back Gitea installation");

        // Uninstall Helm release
        let output = Command::new("helm")
            .arg("uninstall")
            .arg(&self.config.release_name)
            .arg("--namespace")
            .arg(&self.config.namespace)
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .output();

        if let Ok(output) = output {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                warn!("Failed to uninstall Helm release: {}", stderr);
            }
        }

        // Delete namespace (this will clean up all resources)
        let ns_output = Command::new("kubectl")
            .arg("delete")
            .arg("namespace")
            .arg(&self.config.namespace)
            .arg("--ignore-not-found=true")
            .env("KUBECONFIG", &self.config.kubeconfig_path)
            .output();

        if let Ok(output) = ns_output {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                warn!("Failed to delete namespace: {}", stderr);
            }
        }

        // Cleanup temporary files
        let _ = self.cleanup();

        info!("Rollback completed");
        Ok(())
    }

    /// Get admin credentials
    pub fn get_credentials(&self) -> (String, String) {
        (
            self.config.admin_user.clone(),
            self.config.admin_password.clone(),
        )
    }
}

impl Default for GiteaInstaller {
    fn default() -> Self {
        Self::new().expect("Failed to create default GiteaInstaller")
    }
}

/// Service information for accessing Gitea
#[derive(Debug, Clone)]
pub struct ServiceInfo {
    pub service_type: String,
    pub node_port: Option<u16>,
    pub load_balancer_ip: Option<String>,
    #[allow(dead_code)]
    pub namespace: String,
}

impl ServiceInfo {
    /// Get access URL for Gitea
    pub fn access_url(&self) -> String {
        match (
            self.service_type.as_str(),
            &self.load_balancer_ip,
            self.node_port,
        ) {
            ("LoadBalancer", Some(ip), _) => format!("http://{}:3000", ip),
            ("NodePort", _, Some(port)) => format!("http://localhost:{}", port),
            _ => "http://localhost:3000 (ClusterIP - use port-forward)".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = GiteaConfig::default();
        assert_eq!(config.namespace, GITEA_NAMESPACE);
        assert_eq!(config.release_name, GITEA_RELEASE_NAME);
        assert_eq!(config.admin_user, "raibid-admin");
        assert!(config.enable_oci_registry);
        assert_eq!(config.service_type, ServiceType::NodePort);
    }

    #[test]
    fn test_service_type_as_str() {
        assert_eq!(ServiceType::NodePort.as_str(), "NodePort");
        assert_eq!(ServiceType::LoadBalancer.as_str(), "LoadBalancer");
        assert_eq!(ServiceType::ClusterIP.as_str(), "ClusterIP");
    }

    #[test]
    fn test_generate_password() {
        let password = GiteaConfig::generate_password();
        assert_eq!(password.len(), 16);
        assert!(password
            .chars()
            .all(|c| c.is_alphanumeric() || "!@#$%^&*".contains(c)));
    }

    #[test]
    fn test_generate_helm_values() {
        let config = GiteaConfig {
            admin_user: "testadmin".to_string(),
            admin_password: "testpass123".to_string(),
            admin_email: "test@example.com".to_string(),
            enable_oci_registry: true,
            service_type: ServiceType::NodePort,
            http_node_port: Some(30080),
            ssh_node_port: Some(30022),
            storage_size: "10Gi".to_string(),
            storage_class: "local-path".to_string(),
            ..Default::default()
        };

        let values = config.generate_helm_values();

        // Verify key configuration elements
        assert!(values.contains("username: testadmin"));
        assert!(values.contains("password: testpass123"));
        assert!(values.contains("email: test@example.com"));
        assert!(values.contains("ENABLED: true"));
        assert!(values.contains("type: NodePort"));
        assert!(values.contains("nodePort: 30080"));
        assert!(values.contains("nodePort: 30022"));
        assert!(values.contains("size: 10Gi"));
        assert!(values.contains("storageClass: local-path"));
    }

    #[test]
    fn test_generate_helm_values_loadbalancer() {
        let config = GiteaConfig {
            service_type: ServiceType::LoadBalancer,
            ..Default::default()
        };

        let values = config.generate_helm_values();
        assert!(values.contains("type: LoadBalancer"));
        assert!(!values.contains("nodePort"));
    }

    #[test]
    fn test_generate_helm_values_no_oci() {
        let config = GiteaConfig {
            enable_oci_registry: false,
            ..Default::default()
        };

        let values = config.generate_helm_values();
        assert!(values.contains("ENABLED: false"));
    }

    #[test]
    fn test_installer_creation() {
        let installer = GiteaInstaller::new();
        assert!(installer.is_ok(), "Installer creation should succeed");
    }

    #[test]
    fn test_service_info_access_url() {
        let info_lb = ServiceInfo {
            service_type: "LoadBalancer".to_string(),
            node_port: None,
            load_balancer_ip: Some("10.0.0.1".to_string()),
            namespace: "gitea".to_string(),
        };
        assert_eq!(info_lb.access_url(), "http://10.0.0.1:3000");

        let info_np = ServiceInfo {
            service_type: "NodePort".to_string(),
            node_port: Some(30080),
            load_balancer_ip: None,
            namespace: "gitea".to_string(),
        };
        assert_eq!(info_np.access_url(), "http://localhost:30080");

        let info_cluster = ServiceInfo {
            service_type: "ClusterIP".to_string(),
            node_port: None,
            load_balancer_ip: None,
            namespace: "gitea".to_string(),
        };
        assert!(info_cluster.access_url().contains("port-forward"));
    }
}
